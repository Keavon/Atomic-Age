Shader "Custom/Depth2D" {
	Properties {
		[NoScaleOffset] _MainTex ("Color Pixel Texture", 2D) = "white" {}
		[NoScaleOffset] _XMap ("X Pixel Position Map", 2D) = "white" {}
		[NoScaleOffset] _ZMap ("Z Pixel Depth Map", 2D) = "white" {}
		_ObjectBoundsStart ("Starting point left of object", Range(0.0, 1.0)) = 1.0
	}

	SubShader {
		Tags { "Queue"="Transparent" "RenderType" = "Opaque" }
		// LOD 100

		Pass {
			CGPROGRAM

			#include "UnityCG.cginc"
			#pragma vertex vert
			#pragma fragment frag
			#pragma target 4.0
			
			sampler2D _MainTex;
			sampler2D _XMap;
			float4 _XMap_TexelSize;
			sampler2D _ZMap;
			float _ObjectBoundsStart;

			// Input to vertex shader
			struct appdata {
				float4 vertex : POSITION; // Vertex position
				float2 uv : TEXCOORD0; // Texture coordinate
			};

			// Output from vertex shader, input to fragment shader
			struct vertexToFragment {
				float2 uv : TEXCOORD0; // Texture coordinate
				float4 vertex : SV_POSITION; // Clip space position
			};
			
			// Vertex shader
			vertexToFragment vert(appdata input) {
				vertexToFragment output;
				output.vertex = UnityObjectToClipPos(input.vertex);
				output.uv = input.uv;
				return output;
			}
			
			// Fragment shader
			fixed4 frag(vertexToFragment input) : SV_Target {
				if (input.uv.x < _ObjectBoundsStart) discard;

				float fragmentPercentInObject = (input.uv.x - _ObjectBoundsStart) / (1 - _ObjectBoundsStart);
				
				float mapWidth = _XMap_TexelSize.z;
				float mapHeight = _XMap_TexelSize.w;
				float u;
				float v = input.uv.y;
				for (int i = 0; i < 1023; i++) {
					u = (i + 0.5) / mapWidth;
					float sampleAtTexel = tex2D(_XMap, float2(u, v));
					if (sampleAtTexel < fragmentPercentInObject) break;
				}
				return tex2D(_MainTex, float2(u, v));

				// float texelObjectX = tex2D(_XMap, input.uv).a;

				// float effectiveXPosition = input.uv.x * objectBoundsRange + _ObjectBoundsStart;
				// // if (effectiveXPosition == 0) discard; // Discard black, everything left of the effective image
				// float2 effectiveSampleUVs = float2(effectiveXPosition, input.uv.y);
				// fixed4 effectivePixelColor = tex2D(_MainTex, effectiveSampleUVs);
				// return effectivePixelColor;
			}

			ENDCG
		}
	}
}
